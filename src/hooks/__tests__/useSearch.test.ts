/**
 * Context7 Enhanced Search Hook Tests
 * Comprehensive testing for hierarchical search functionality
 */

import { renderHook, act } from '@testing-library/react';
import { useSearch } from '../useSearch';
import { searchApi } from '../../api/searchApi';

// Mock the search API
jest.mock('../../api/searchApi', () => ({
  searchApi: {
    searchSets: jest.fn(),
    searchCards: jest.fn(),
    searchProducts: jest.fn(),
    searchCategories: jest.fn(),
  },
}));

// Mock logger
jest.mock('../../utils/logger', () => ({
  log: jest.fn(),
}));

// Mock error handler
jest.mock('../../utils/errorHandler', () => ({
  handleApiError: jest.fn(),
}));

const mockSearchApi = searchApi as jest.Mocked<typeof searchApi>;

describe('useSearch - Context7 Enhanced Search Hook', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    jest.clearAllTimers();
    jest.useFakeTimers();
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  describe('Hierarchical Search Flow', () => {
    test('should implement proper hierarchical search logic', async () => {
      const mockSetResults = [
        { setName: 'Base Set', year: 1999, score: 100, source: 'cards' as const, isExactMatch: true },
      ];\n      const mockCardResults = [\n        {\n          _id: 'card1',\n          cardName: 'Pikachu',\n          baseName: 'Pikachu',\n          setInfo: { setName: 'Base Set', year: 1999 },\n        },\n      ];\n\n      mockSearchApi.searchSets.mockResolvedValue(mockSetResults);\n      mockSearchApi.searchCards.mockResolvedValue(mockCardResults);\n\n      const { result } = renderHook(() => useSearch());\n\n      // Step 1: Search for set\n      act(() => {\n        result.current.updateSetName('base');\n      });\n\n      // Fast-forward debounce timer\n      act(() => {\n        jest.advanceTimersByTime(200);\n      });\n\n      await act(async () => {\n        await Promise.resolve(); // Wait for async operations\n      });\n\n      expect(mockSearchApi.searchSets).toHaveBeenCalledWith('base', 'set');\n      expect(result.current.suggestions).toEqual(mockSetResults);\n\n      // Step 2: Select set\n      act(() => {\n        result.current.handleSuggestionSelect(mockSetResults[0], 'set');\n      });\n\n      expect(result.current.selectedSet).toBe('Base Set');\n      expect(result.current.setName).toBe('Base Set');\n      expect(result.current.suggestions).toEqual([]); // Should clear suggestions\n\n      // Step 3: Search for card within selected set\n      act(() => {\n        result.current.updateCardProductName('pikachu');\n      });\n\n      act(() => {\n        jest.advanceTimersByTime(200);\n      });\n\n      await act(async () => {\n        await Promise.resolve();\n      });\n\n      expect(mockSearchApi.searchCards).toHaveBeenCalledWith(\n        'pikachu',\n        'Base Set', // Should pass set context\n        undefined, // No category context\n        15 // Increased limit for better results\n      );\n    });\n\n    test('should auto-fill set information when selecting card/product', async () => {\n      const mockCardWithSetInfo = {\n        _id: 'card1',\n        cardName: 'Charizard',\n        baseName: 'Charizard',\n        setInfo: { setName: 'Base Set', year: 1999 },\n      };\n\n      mockSearchApi.searchCards.mockResolvedValue([mockCardWithSetInfo]);\n\n      const { result } = renderHook(() => useSearch());\n\n      // Search for card\n      act(() => {\n        result.current.updateCardProductName('charizard');\n      });\n\n      act(() => {\n        jest.advanceTimersByTime(200);\n      });\n\n      await act(async () => {\n        await Promise.resolve();\n      });\n\n      // Select card\n      act(() => {\n        result.current.handleSuggestionSelect(mockCardWithSetInfo, 'cardProduct');\n      });\n\n      // Should auto-fill set information\n      expect(result.current.setName).toBe('Base Set');\n      expect(result.current.selectedSet).toBe('Base Set');\n      expect(result.current.cardProductName).toBe('Charizard');\n      expect(result.current.selectedCardData).toBeTruthy();\n    });\n\n    test('should prevent cross-field suggestion contamination', async () => {\n      const mockSetResults = [{ setName: 'Base Set', year: 1999, score: 100, source: 'cards' as const, isExactMatch: true }];\n      const mockCardResults = [{ _id: 'card1', cardName: 'Pikachu', baseName: 'Pikachu' }];\n\n      mockSearchApi.searchSets.mockResolvedValue(mockSetResults);\n      mockSearchApi.searchCards.mockResolvedValue(mockCardResults);\n\n      const { result } = renderHook(() => useSearch());\n\n      // Start typing in set field\n      act(() => {\n        result.current.updateSetName('base');\n      });\n\n      expect(result.current.activeField).toBe('set');\n\n      // Switch to card field\n      act(() => {\n        result.current.updateCardProductName('pikachu');\n      });\n\n      expect(result.current.activeField).toBe('cardProduct');\n      // Should clear suggestions when switching fields\n      expect(result.current.suggestions).toEqual([]);\n    });\n  });\n\n  describe('Context7 Performance Optimizations', () => {\n    test('should implement debounced search requests', async () => {\n      const { result } = renderHook(() => useSearch());\n\n      // Type rapidly\n      act(() => {\n        result.current.updateSetName('b');\n      });\n      act(() => {\n        result.current.updateSetName('ba');\n      });\n      act(() => {\n        result.current.updateSetName('base');\n      });\n\n      // Should not call API immediately\n      expect(mockSearchApi.searchSets).not.toHaveBeenCalled();\n\n      // Fast-forward debounce timer\n      act(() => {\n        jest.advanceTimersByTime(200);\n      });\n\n      await act(async () => {\n        await Promise.resolve();\n      });\n\n      // Should only call API once with final value\n      expect(mockSearchApi.searchSets).toHaveBeenCalledTimes(1);\n      expect(mockSearchApi.searchSets).toHaveBeenCalledWith('base', 'set');\n    });\n\n    test('should cache search results', async () => {\n      const mockResults = [{ setName: 'Base Set', year: 1999, score: 100, source: 'cards' as const, isExactMatch: true }];\n      mockSearchApi.searchSets.mockResolvedValue(mockResults);\n\n      const { result } = renderHook(() => useSearch());\n\n      // First search\n      act(() => {\n        result.current.updateSetName('base');\n      });\n\n      act(() => {\n        jest.advanceTimersByTime(200);\n      });\n\n      await act(async () => {\n        await Promise.resolve();\n      });\n\n      expect(mockSearchApi.searchSets).toHaveBeenCalledTimes(1);\n\n      // Clear and search again with same query\n      act(() => {\n        result.current.updateSetName('');\n      });\n\n      act(() => {\n        result.current.updateSetName('base');\n      });\n\n      act(() => {\n        jest.advanceTimersByTime(200);\n      });\n\n      await act(async () => {\n        await Promise.resolve();\n      });\n\n      // Should use cached result (API called only once)\n      expect(mockSearchApi.searchSets).toHaveBeenCalledTimes(1);\n      expect(result.current.suggestions).toEqual(mockResults);\n    });\n\n    test('should implement input preprocessing', async () => {\n      const { result } = renderHook(() => useSearch());\n\n      // Test with whitespace and mixed case\n      act(() => {\n        result.current.updateSetName('  BASE SET  ');\n      });\n\n      act(() => {\n        jest.advanceTimersByTime(200);\n      });\n\n      await act(async () => {\n        await Promise.resolve();\n      });\n\n      // Should normalize the query\n      expect(mockSearchApi.searchSets).toHaveBeenCalledWith('base set', 'set');\n    });\n\n    test('should handle minimum character length', async () => {\n      const { result } = renderHook(() => useSearch());\n\n      // Test with query too short\n      act(() => {\n        result.current.updateSetName('b');\n      });\n\n      act(() => {\n        jest.advanceTimersByTime(200);\n      });\n\n      await act(async () => {\n        await Promise.resolve();\n      });\n\n      // Should not call API for queries less than 2 characters\n      expect(mockSearchApi.searchSets).not.toHaveBeenCalled();\n      expect(result.current.suggestions).toEqual([]);\n    });\n  });\n\n  describe('Context7 Search Modes', () => {\n    test('should switch between cards and products search modes', async () => {\n      const mockCardResults = [{ _id: 'card1', cardName: 'Pikachu', baseName: 'Pikachu' }];\n      const mockProductResults = [{ _id: 'product1', name: 'Booster Pack', category: 'Boosters', available: true, price: 10 }];\n\n      mockSearchApi.searchCards.mockResolvedValue(mockCardResults);\n      mockSearchApi.searchProducts.mockResolvedValue(mockProductResults);\n\n      const { result } = renderHook(() => useSearch());\n\n      // Default mode should be cards\n      act(() => {\n        result.current.updateCardProductName('pikachu');\n      });\n\n      act(() => {\n        jest.advanceTimersByTime(200);\n      });\n\n      await act(async () => {\n        await Promise.resolve();\n      });\n\n      expect(mockSearchApi.searchCards).toHaveBeenCalled();\n      expect(mockSearchApi.searchProducts).not.toHaveBeenCalled();\n\n      // Switch to products mode\n      act(() => {\n        result.current.setSearchMode('products');\n      });\n\n      act(() => {\n        result.current.updateCardProductName('booster');\n      });\n\n      act(() => {\n        jest.advanceTimersByTime(200);\n      });\n\n      await act(async () => {\n        await Promise.resolve();\n      });\n\n      expect(mockSearchApi.searchProducts).toHaveBeenCalled();\n    });\n  });\n\n  describe('Error Handling', () => {\n    test('should handle API errors gracefully', async () => {\n      const mockError = new Error('API Error');\n      mockSearchApi.searchSets.mockRejectedValue(mockError);\n\n      const { result } = renderHook(() => useSearch());\n\n      act(() => {\n        result.current.updateSetName('base');\n      });\n\n      act(() => {\n        jest.advanceTimersByTime(200);\n      });\n\n      await act(async () => {\n        await Promise.resolve();\n      });\n\n      expect(result.current.suggestions).toEqual([]);\n      expect(result.current.loading).toBe(false);\n    });\n  });\n\n  describe('State Management', () => {\n    test('should clear selected set when field is emptied', async () => {\n      const { result } = renderHook(() => useSearch());\n\n      // Set a selected set\n      act(() => {\n        result.current.handleSuggestionSelect(\n          { setName: 'Base Set', year: 1999, score: 100, source: 'cards' as const, isExactMatch: true },\n          'set'\n        );\n      });\n\n      expect(result.current.selectedSet).toBe('Base Set');\n\n      // Clear the field\n      act(() => {\n        result.current.updateSetName('');\n      });\n\n      expect(result.current.selectedSet).toBeNull();\n    });\n\n    test('should maintain selectedSet when typing in same field', async () => {\n      const { result } = renderHook(() => useSearch());\n\n      // Set a selected set\n      act(() => {\n        result.current.handleSuggestionSelect(\n          { setName: 'Base Set', year: 1999, score: 100, source: 'cards' as const, isExactMatch: true },\n          'set'\n        );\n      });\n\n      expect(result.current.selectedSet).toBe('Base Set');\n\n      // Continue typing in set field\n      act(() => {\n        result.current.updateSetName('Base Set 2');\n      });\n\n      // Should maintain selectedSet until explicitly cleared\n      expect(result.current.selectedSet).toBe('Base Set');\n    });\n  });\n});"}